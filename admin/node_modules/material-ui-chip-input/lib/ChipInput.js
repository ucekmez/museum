'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultChipRenderer = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _Input = require('@material-ui/core/Input');

var _Input2 = _interopRequireDefault(_Input);

var _InputLabel = require('@material-ui/core/InputLabel');

var _InputLabel2 = _interopRequireDefault(_InputLabel);

var _Chip = require('@material-ui/core/Chip');

var _Chip2 = _interopRequireDefault(_Chip);

var _withStyles = require('@material-ui/core/styles/withStyles');

var _withStyles2 = _interopRequireDefault(_withStyles);

var _blue = require('@material-ui/core/colors/blue');

var _blue2 = _interopRequireDefault(_blue);

var _FormControl = require('@material-ui/core/FormControl');

var _FormControl2 = _interopRequireDefault(_FormControl);

var _FormHelperText = require('@material-ui/core/FormHelperText');

var _FormHelperText2 = _interopRequireDefault(_FormHelperText);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Notice: Some code was adapted from Material-UI's text field.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         Copyright (c) 2014 Call-Em-All (https://github.com/callemall/material-ui)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


var styles = function styles(theme) {
  var light = theme.palette.type === 'light';
  var bottomLineColor = light ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)';

  return {
    root: {},
    inputRoot: {
      display: 'inline-block',
      marginTop: 0
    },
    input: {
      display: 'inline-block',
      appearance: 'none', // Remove border in Safari, doesn't seem to break anything in other browsers
      WebkitTapHighlightColor: 'rgba(0,0,0,0)', // Remove mobile color flashing (deprecated style).
      float: 'left'
    },
    chipContainer: {
      cursor: 'text',
      marginBottom: -2,
      minHeight: 40,
      '&$labeled': {
        marginTop: 18
      }
    },
    labeled: {},
    label: {
      top: 4
    },
    labelShrink: {
      top: 0
    },
    helperText: {
      marginBottom: -20
    },
    inkbar: {
      '&:after': {
        backgroundColor: theme.palette.primary[light ? 'dark' : 'light'],
        left: 0,
        bottom: 0,
        // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
        content: '""',
        height: 2,
        position: 'absolute',
        right: 0,
        transform: 'scaleX(0)',
        transition: theme.transitions.create('transform', {
          duration: theme.transitions.duration.shorter,
          easing: theme.transitions.easing.easeOut
        }),
        pointerEvents: 'none' // Transparent to the hover style.
      },
      '&$focused:after': {
        transform: 'scaleX(1)'
      }
    },
    focused: {},
    disabled: {},
    underline: {
      '&:before': {
        backgroundColor: bottomLineColor,
        left: 0,
        bottom: 0,
        // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
        content: '""',
        height: 1,
        position: 'absolute',
        right: 0,
        transition: theme.transitions.create('background-color', {
          duration: theme.transitions.duration.shorter,
          easing: theme.transitions.easing.ease
        }),
        pointerEvents: 'none' // Transparent to the hover style.
      },
      '&:hover:not($disabled):before': {
        backgroundColor: theme.palette.text.primary,
        height: 2
      },
      '&$disabled:before': {
        background: 'transparent',
        backgroundImage: 'linear-gradient(to right, ' + bottomLineColor + ' 33%, transparent 0%)',
        backgroundPosition: 'left top',
        backgroundRepeat: 'repeat-x',
        backgroundSize: '5px 1px'
      }
    },
    error: {
      '&:after': {
        backgroundColor: theme.palette.error.A400,
        transform: 'scaleX(1)' // error is always underlined in red
      }
    },
    chip: {
      margin: '0 8px 8px 0',
      float: 'left'
    }
  };
};

var defaultChipRenderer = exports.defaultChipRenderer = function defaultChipRenderer(_ref, key) {
  var value = _ref.value,
      text = _ref.text,
      isFocused = _ref.isFocused,
      isDisabled = _ref.isDisabled,
      handleClick = _ref.handleClick,
      handleDelete = _ref.handleDelete,
      className = _ref.className;
  return _react2.default.createElement(_Chip2.default, {
    key: key,
    className: className,
    style: { pointerEvents: isDisabled ? 'none' : undefined, backgroundColor: isFocused ? _blue2.default[300] : undefined },
    onClick: handleClick,
    onDelete: handleDelete,
    label: text
  });
};

var ChipInput = function (_React$Component) {
  _inherits(ChipInput, _React$Component);

  function ChipInput(props) {
    _classCallCheck(this, ChipInput);

    var _this = _possibleConstructorReturn(this, (ChipInput.__proto__ || Object.getPrototypeOf(ChipInput)).call(this, props));

    _this.state = {
      isFocused: false,
      errorText: undefined,
      isClean: true,
      chips: [],
      focusedChip: null,
      inputValue: ''
    };

    _this.focus = function () {
      _this.actualInput.focus();
      // this.getInputNode().focus()
      // if (this.props.openOnFocus && !this.props.disabled) {
      // }
      if (_this.state.focusedChip != null) {
        _this.setState({ focusedChip: null });
      }
    };

    _this.handleInputBlur = function (event) {
      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
      _this.setState({ isFocused: false });
      if (_this.state.focusedChip != null) {
        _this.setState({ focusedChip: null });
      }
      if (_this.props.blurBehavior === 'add') {
        // Lets assume that we only want to add the existing content as chip, when
        // another event has not added a chip within 200ms .
        // e.g. onSelection Callback in Autocomplete case
        var numChipsBefore = (_this.props.value || _this.state.chips).length;
        var value = event.target.value;
        _this.inputBlurTimeout = setTimeout(function () {
          var numChipsAfter = (_this.props.value || _this.state.chips).length;
          if (numChipsBefore === numChipsAfter) {
            _this.handleAddChip(value);
          } else {
            _this.clearInput();
          }
        }, 150);
      } else if (_this.props.blurBehavior === 'clear') {
        _this.clearInput();
      }

      // A momentary delay is required to support openOnFocus. We must give time for the autocomplete
      // menu to close before checking the current status. Otherwise, tabbing off the input while the
      // menu is open results in the input keeping its focus styles. Note that the ref might not be set
      // yet, so this.autocomplete might be null.
      // setTimeout(() => {
      //   if (this.autoComplete && (!this.autoComplete.state.open || this.autoComplete.requestsList.length === 0)) {
      //     if (this.props.clearOnBlur) {
      //       this.clearInput()
      //     }
      //     this.setState({ isFocused: false })
      //   }
      // }, 0)
    };

    _this.handleInputFocus = function (event) {
      _this.setState({ isFocused: true });
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
    };

    _this.handleKeyDown = function (event) {
      var focusedChip = _this.state.focusedChip;

      _this.setState({ keyPressed: false, preventChipCreation: false });

      if (_this.props.newChipKeyCodes.indexOf(event.keyCode) >= 0) {
        _this.handleAddChip(event.target.value);
      } else if (event.keyCode === 8 || event.keyCode === 46) {
        if (event.target.value === '') {
          var chips = _this.props.value || _this.state.chips;
          if (focusedChip == null && event.keyCode === 8) {
            _this.setState({ focusedChip: chips.length - 1 });
          } else if (focusedChip != null) {
            var _chips = _this.props.value || _this.state.chips;
            var value = _chips[focusedChip];
            _this.handleDeleteChip(value, focusedChip);
            if (event.keyCode === 8 && focusedChip > 0) {
              _this.setState({ focusedChip: focusedChip - 1 });
            } else if (event.keyCode === 46 && focusedChip <= _chips.length - 1) {
              _this.setState({ focusedChip: focusedChip });
            }
          }
        }
      } else if (event.keyCode === 37) {
        var _chips2 = _this.props.value || _this.state.chips;
        if (focusedChip == null && event.target.value === '' && _chips2.length) {
          return _this.setState({ focusedChip: _chips2.length - 1 });
        }
        if (focusedChip != null && focusedChip > 0) {
          _this.setState({ focusedChip: focusedChip - 1 });
        }
      } else if (event.keyCode === 39) {
        var _chips3 = _this.props.value || _this.state.chips;
        if (focusedChip != null && focusedChip < _chips3.length - 1) {
          _this.setState({ focusedChip: focusedChip + 1 });
        } else {
          _this.setState({ focusedChip: null });
        }
      } else {
        _this.setState({ focusedChip: null });
      }
    };

    _this.handleKeyUp = function (event) {
      if (!_this.state.preventChipCreation && _this.props.newChipKeyCodes.indexOf(event.keyCode) > 0 && _this.state.keyPressed) {
        _this.clearInput();
      } else {
        _this.setState({ inputValue: event.target.value });
      }
    };

    _this.handleKeyPress = function (event) {
      _this.setState({ keyPressed: true });
    };

    _this.handleUpdateInput = function (e) {
      _this.setState({ inputValue: e.target.value });

      if (_this.props.onUpdateInput) {
        // this.props.onUpdateInput(searchText, dataSource, params)
        _this.props.onUpdateInput(e.target.value);
      }
    };

    _this.setInputRef = function (input) {
      _this.input = input;
    };

    if (props.defaultValue) {
      _this.state.chips = props.defaultValue;
    }
    return _this;
  }

  _createClass(ChipInput, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearTimeout(this.inputBlurTimeout);
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      // const handleKeyDown = this.autoComplete.handleKeyDown
      // this.autoComplete.handleKeyDown = (event) => {
      //   const {newChipKeyCodes} = this.props
      //   if (newChipKeyCodes.indexOf(event.keyCode) >= 0 && event.target.value) {
      //     event.preventDefault()
      //     this.handleAddChip(event.target.value)
      //     this.autoComplete.forceUpdate()
      //   } else {
      //     handleKeyDown(event)
      //   }
      // }

      // this.autoComplete.handleItemTouchTap = (event, child) => {
      //   const dataSource = this.autoComplete.props.dataSource

      //   const index = parseInt(child.key, 10)
      //   const chosenRequest = dataSource[index]
      //   this.handleAddChip(chosenRequest)
      //   this.autoComplete.forceUpdate()
      //   this.autoComplete.close()

      //   setTimeout(() => this.focus(), 1)
      // }

      // // force update autocomplete to ensure that it uses the new handlers
      // this.autoComplete.forceUpdate()
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.disabled) {
        this.setState({ focusedChip: null });
      }
    }

    /**
     * Blurs this component.
     * @public
     */

  }, {
    key: 'blur',
    value: function blur() {
      if (this.input) this.actualInput.blur();
    }

    /**
     * Focuses this component.
     * @public
     */

  }, {
    key: 'handleAddChip',
    value: function handleAddChip(chip) {
      var _this2 = this;

      if (this.props.onBeforeAdd && !this.props.onBeforeAdd(chip)) {
        return this.setState({ preventChipCreation: true });
      }
      this.setState({ inputValue: '' });
      var chips = this.props.value || this.state.chips;

      if (this.props.dataSourceConfig) {
        if (typeof chip === 'string') {
          var _chip;

          chip = (_chip = {}, _defineProperty(_chip, this.props.dataSourceConfig.text, chip), _defineProperty(_chip, this.props.dataSourceConfig.value, chip), _chip);
        }

        if (this.props.allowDuplicates || !chips.some(function (c) {
          return c[_this2.props.dataSourceConfig.value] === chip[_this2.props.dataSourceConfig.value];
        })) {
          if (this.props.value && this.props.onAdd) {
            this.props.onAdd(chip);
          } else {
            this.setState({ chips: [].concat(_toConsumableArray(this.state.chips), [chip]) });
            if (this.props.onChange) {
              this.props.onChange([].concat(_toConsumableArray(this.state.chips), [chip]));
            }
          }
        }
      } else if (chip.trim().length > 0) {
        if (this.props.allowDuplicates || chips.indexOf(chip) === -1) {
          if (this.props.value && this.props.onAdd) {
            this.props.onAdd(chip);
          } else {
            this.setState({ chips: [].concat(_toConsumableArray(this.state.chips), [chip]) });
            if (this.props.onChange) {
              this.props.onChange([].concat(_toConsumableArray(this.state.chips), [chip]));
            }
          }
        }
      }
    }
  }, {
    key: 'handleDeleteChip',
    value: function handleDeleteChip(chip, i) {
      if (this.props.value) {
        if (this.props.onDelete) {
          this.props.onDelete(chip, i);
        }
      } else {
        var chips = this.state.chips.slice();
        var changed = chips.splice(i, 1); // remove the chip at index i
        if (changed) {
          var focusedChip = this.state.focusedChip;
          if (this.state.focusedChip === i) {
            focusedChip = null;
          } else if (this.state.focusedChip > i) {
            focusedChip = this.state.focusedChip - 1;
          }
          this.setState({ chips: chips, focusedChip: focusedChip });
          if (this.props.onChange) {
            this.props.onChange(chips);
          }
        }
      }
    }

    /**
     * Clears the text field for adding new chips.
     * @public
     */

  }, {
    key: 'clearInput',
    value: function clearInput() {
      this.setState({ inputValue: '' });
    }

    /**
     * Sets a reference to the AutoComplete instance.
     *
     * Using a bound class method here to set `autoComplete` to avoid it being set
     * to null by an inline ref callback.
     *
     * See [Issue #71](https://github.com/TeamWertarbyte/material-ui-chip-input/issues/71)
     *
     * @param {Object} autoComplete - The AutoComplete DOM element or null
     */

  }, {
    key: 'render',
    value: function render() {
      var _cx,
          _this3 = this;

      var _props = this.props,
          allowDuplicates = _props.allowDuplicates,
          blurBehavior = _props.blurBehavior,
          children = _props.children,
          _props$chipRenderer = _props.chipRenderer,
          chipRenderer = _props$chipRenderer === undefined ? defaultChipRenderer : _props$chipRenderer,
          classes = _props.classes,
          className = _props.className,
          _props$defaultValue = _props.defaultValue,
          defaultValue = _props$defaultValue === undefined ? [] : _props$defaultValue,
          dataSource = _props.dataSource,
          dataSourceConfig = _props.dataSourceConfig,
          disabled = _props.disabled,
          disableUnderline = _props.disableUnderline,
          error = _props.error,
          filter = _props.filter,
          FormHelperTextProps = _props.FormHelperTextProps,
          fullWidth = _props.fullWidth,
          fullWidthInput = _props.fullWidthInput,
          helperText = _props.helperText,
          helperTextClassName = _props.helperTextClassName,
          id = _props.id,
          _inputRef = _props.inputRef,
          InputLabelProps = _props.InputLabelProps,
          label = _props.label,
          labelClassName = _props.labelClassName,
          newChipKeyCodes = _props.newChipKeyCodes,
          onBeforeAdd = _props.onBeforeAdd,
          onAdd = _props.onAdd,
          onDelete = _props.onDelete,
          onBlur = _props.onBlur,
          onChange = _props.onChange,
          onFocus = _props.onFocus,
          onUpdateInput = _props.onUpdateInput,
          placeholder = _props.placeholder,
          required = _props.required,
          rootRef = _props.rootRef,
          value = _props.value,
          other = _objectWithoutProperties(_props, ['allowDuplicates', 'blurBehavior', 'children', 'chipRenderer', 'classes', 'className', 'defaultValue', 'dataSource', 'dataSourceConfig', 'disabled', 'disableUnderline', 'error', 'filter', 'FormHelperTextProps', 'fullWidth', 'fullWidthInput', 'helperText', 'helperTextClassName', 'id', 'inputRef', 'InputLabelProps', 'label', 'labelClassName', 'newChipKeyCodes', 'onBeforeAdd', 'onAdd', 'onDelete', 'onBlur', 'onChange', 'onFocus', 'onUpdateInput', 'placeholder', 'required', 'rootRef', 'value']);

      var chips = this.props.value || this.state.chips;
      // const autoCompleteData = dataSourceConfig
      //   ? (dataSource || []).filter((value) => !chips.some((c) => c[dataSourceConfig.value] === value[dataSourceConfig.value]))
      //   : (dataSource || []).filter((value) => chips.indexOf(value) < 0)

      // const actualFilter = openOnFocus ? (search, key) => (search === '' || filter(search, key)) : filter

      var hasInput = (this.props.value || this.state.chips).length > 0 || this.state.inputValue.length > 0;
      // const showPlaceholder = placeholder && !hasInput
      var shrinkFloatingLabel = label != null && (hasInput || this.state.isFocused);

      return _react2.default.createElement(
        _FormControl2.default,
        _extends({
          ref: rootRef,
          fullWidth: fullWidth,
          className: (0, _classnames2.default)(className, classes.root),
          error: error,
          required: required,
          onClick: this.focus,
          disabled: disabled
        }, other),
        label && _react2.default.createElement(
          _InputLabel2.default,
          _extends({
            htmlFor: id,
            className: labelClassName,
            classes: { root: classes.label, shrink: classes.labelShrink },
            shrink: shrinkFloatingLabel,
            focused: this.state.isFocused
          }, InputLabelProps),
          label
        ),
        _react2.default.createElement(
          'div',
          { className: (0, _classnames2.default)(classes.chipContainer, (_cx = {}, _defineProperty(_cx, classes.inkbar, !disableUnderline), _defineProperty(_cx, classes.focused, this.state.isFocused), _defineProperty(_cx, classes.underline, !disableUnderline), _defineProperty(_cx, classes.disabled, disabled), _defineProperty(_cx, classes.labeled, label != null), _defineProperty(_cx, classes.error, error), _cx))
          },
          chips.map(function (tag, i) {
            var value = dataSourceConfig ? tag[dataSourceConfig.value] : tag;
            return chipRenderer({
              value: value,
              text: dataSourceConfig ? tag[dataSourceConfig.text] : tag,
              chip: tag,
              isDisabled: !!disabled,
              isFocused: _this3.state.focusedChip === i,
              handleClick: function handleClick() {
                return _this3.setState({ focusedChip: i });
              },
              handleDelete: function handleDelete() {
                return _this3.handleDeleteChip(value, i);
              },
              className: classes.chip
            }, i);
          }),
          _react2.default.createElement(_Input2.default, _extends({
            ref: this.setInputRef,
            classes: { input: classes.input, root: classes.inputRoot },
            id: id,
            value: this.state.inputValue,
            onChange: this.handleUpdateInput,
            onKeyDown: this.handleKeyDown,
            onKeyPress: this.handleKeyPress,
            onKeyUp: this.handleKeyUp,
            onFocus: this.handleInputFocus,
            onBlur: this.handleInputBlur,
            inputRef: function inputRef(ref) {
              _this3.actualInput = ref;_inputRef(ref);
            },
            disabled: disabled,
            disableUnderline: true,
            fullWidth: fullWidthInput,
            placeholder: !hasInput && (shrinkFloatingLabel || label == null) ? placeholder : null
          }, other))
        ),
        helperText && _react2.default.createElement(
          _FormHelperText2.default,
          _extends({ className: (0, _classnames2.default)(helperTextClassName, classes.helperText) }, FormHelperTextProps),
          helperText
        )
      );
    }
  }]);

  return ChipInput;
}(_react2.default.Component);

ChipInput.propTypes = {
  style: _propTypes2.default.object,
  chipContainerStyle: _propTypes2.default.object,
  dataSourceConfig: _propTypes2.default.shape({
    text: _propTypes2.default.string.isRequired,
    value: _propTypes2.default.string.isRequired
  }),
  disabled: _propTypes2.default.bool,
  defaultValue: _propTypes2.default.array,
  onChange: _propTypes2.default.func,
  value: _propTypes2.default.array,
  onBeforeAdd: _propTypes2.default.func,
  onAdd: _propTypes2.default.func,
  onDelete: _propTypes2.default.func,
  dataSource: _propTypes2.default.array,
  onUpdateInput: _propTypes2.default.func,
  // openOnFocus: PropTypes.bool,
  chipRenderer: _propTypes2.default.func,
  newChipKeyCodes: _propTypes2.default.arrayOf(_propTypes2.default.number),
  allowDuplicates: _propTypes2.default.bool,
  fullWidth: _propTypes2.default.bool,
  fullWidthInput: _propTypes2.default.bool,
  inputRef: _propTypes2.default.func,
  blurBehavior: _propTypes2.default.oneOf(['clear', 'add', 'ignore'])
};

ChipInput.defaultProps = {
  newChipKeyCodes: [13],
  blurBehavior: 'clear',
  allowDuplicates: false,
  inputRef: function inputRef() {}
};

exports.default = (0, _withStyles2.default)(styles)(ChipInput);